{"ast":null,"code":"// import React from 'react';\n// import ReactDOM from 'react-dom/client';\nimport './index.css';\n// import App from './App';\n\n// const root = ReactDOM.createRoot(document.getElementById('root'));\n// root.render(\n//   <React.StrictMode>\n//     <App />\n//   </React.StrictMode>\n// );\n'use strict';\n\n//export function SkinTemptColor(){\nlet preview = document.getElementById(\"preview\");\nlet recording = document.getElementById(\"recording\");\nlet startButton = document.getElementById(\"startButton\");\nlet stopButton = document.getElementById(\"stopButton\");\nlet downloadButton = document.getElementById(\"downloadButton\");\nlet logElement = document.getElementById(\"log\");\nlet recordingTimeMS = 5000;\nfunction log(msg) {\n  logElement.innerHTML += `${msg}\\n`;\n}\nfunction wait(delayInMS) {\n  return new Promise(resolve => setTimeout(resolve, delayInMS));\n}\nfunction startRecording(stream, lengthInMS) {\n  let recorder = new MediaRecorder(stream);\n  let data = [];\n  recorder.ondataavailable = event => data.push(event.data);\n  recorder.start();\n  log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n  let stopped = new Promise((resolve, reject) => {\n    recorder.onstop = resolve;\n    recorder.onerror = event => reject(event.name);\n  });\n  let recorded = wait(lengthInMS).then(() => {\n    if (recorder.state === \"recording\") {\n      recorder.stop();\n    }\n  });\n  return Promise.all([stopped, recorded]).then(() => data);\n}\nstartButton.addEventListener(\"click\", () => {\n  navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true\n  }).then(stream => {\n    preview.srcObject = stream;\n    downloadButton.href = stream;\n    preview.captureStream = preview.captureStream || preview.mozCaptureStream;\n    return new Promise(resolve => preview.onplaying = resolve);\n  }).then(() => startRecording(preview.captureStream(), recordingTimeMS)).then(recordedChunks => {\n    let recordedBlob = new Blob(recordedChunks, {\n      type: \"video/webm\"\n    });\n    recording.src = URL.createObjectURL(recordedBlob);\n    downloadButton.href = recording.src;\n    downloadButton.download = \"RecordedVideo.webm\";\n    log(`Successfully recorded ${recordedBlob.size} bytes of ${recordedBlob.type} media.`);\n  }).catch(error => {\n    if (error.name === \"NotFoundError\") {\n      log(\"Camera or microphone not found. Can't record.\");\n    } else {\n      log(error);\n    }\n  });\n}, false);\nstopButton.addEventListener(\"click\", () => {\n  stop(preview.srcObject);\n}, false);\nfunction stop(stream) {\n  stream.getTracks().forEach(track => track.stop());\n}\n\n//}","map":{"version":3,"names":["preview","document","getElementById","recording","startButton","stopButton","downloadButton","logElement","recordingTimeMS","log","msg","innerHTML","wait","delayInMS","Promise","resolve","setTimeout","startRecording","stream","lengthInMS","recorder","MediaRecorder","data","ondataavailable","event","push","start","state","stopped","reject","onstop","onerror","name","recorded","then","stop","all","addEventListener","navigator","mediaDevices","getUserMedia","video","audio","srcObject","href","captureStream","mozCaptureStream","onplaying","recordedChunks","recordedBlob","Blob","type","src","URL","createObjectURL","download","size","catch","error","getTracks","forEach","track"],"sources":["/Users/wangjiamin/Documents/GitHub/makeup-starters/src/index.js"],"sourcesContent":["// import React from 'react';\n// import ReactDOM from 'react-dom/client';\n import './index.css';\n// import App from './App';\n\n\n// const root = ReactDOM.createRoot(document.getElementById('root'));\n// root.render(\n//   <React.StrictMode>\n//     <App />\n//   </React.StrictMode>\n// );\n'use strict';\n\n//export function SkinTemptColor(){\n    let preview = document.getElementById(\"preview\");\nlet recording = document.getElementById(\"recording\");\nlet startButton = document.getElementById(\"startButton\");\nlet stopButton = document.getElementById(\"stopButton\");\nlet downloadButton = document.getElementById(\"downloadButton\");\nlet logElement = document.getElementById(\"log\");\n\nlet recordingTimeMS = 5000;\n\nfunction log(msg) {\n    logElement.innerHTML += `${msg}\\n`;\n  }\n  \n\n  function wait(delayInMS) {\n    return new Promise((resolve) => setTimeout(resolve, delayInMS));\n  }\n\n  function startRecording(stream, lengthInMS) {\n    let recorder = new MediaRecorder(stream);\n    let data = [];\n  \n    recorder.ondataavailable = (event) => data.push(event.data);\n    recorder.start();\n    log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n  \n    let stopped = new Promise((resolve, reject) => {\n      recorder.onstop = resolve;\n      recorder.onerror = (event) => reject(event.name);\n    });\n  \n    let recorded = wait(lengthInMS).then(() => {\n      if (recorder.state === \"recording\") {\n        recorder.stop();\n      }\n    });\n  \n    return Promise.all([stopped, recorded]).then(() => data);\n  }\n\n\n  startButton.addEventListener(\n    \"click\",\n    () => {\n      navigator.mediaDevices\n        .getUserMedia({\n          video: true,\n          audio: true,\n        })\n        .then((stream) => {\n          preview.srcObject = stream;\n          downloadButton.href = stream;\n          preview.captureStream =\n            preview.captureStream || preview.mozCaptureStream;\n          return new Promise((resolve) => (preview.onplaying = resolve));\n        })\n        .then(() => startRecording(preview.captureStream(), recordingTimeMS))\n        .then((recordedChunks) => {\n          let recordedBlob = new Blob(recordedChunks, { type: \"video/webm\" });\n          recording.src = URL.createObjectURL(recordedBlob);\n          downloadButton.href = recording.src;\n          downloadButton.download = \"RecordedVideo.webm\";\n  \n          log(\n            `Successfully recorded ${recordedBlob.size} bytes of ${recordedBlob.type} media.`\n          );\n        })\n        .catch((error) => {\n          if (error.name === \"NotFoundError\") {\n            log(\"Camera or microphone not found. Can't record.\");\n          } else {\n            log(error);\n          }\n        });\n    },\n    false\n  );\n  stopButton.addEventListener(\n    \"click\",\n    () => {\n      stop(preview.srcObject);\n    },\n    false\n  );\n  \n  function stop(stream) {\n    stream.getTracks().forEach((track) => track.stop());\n  }\n\n\n  \n  \n//}\n"],"mappings":"AAAA;AACA;AACC,OAAO,aAAa;AACrB;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACI,IAAIA,OAAO,GAAGC,QAAQ,CAACC,cAAc,CAAC,SAAS,CAAC;AACpD,IAAIC,SAAS,GAAGF,QAAQ,CAACC,cAAc,CAAC,WAAW,CAAC;AACpD,IAAIE,WAAW,GAAGH,QAAQ,CAACC,cAAc,CAAC,aAAa,CAAC;AACxD,IAAIG,UAAU,GAAGJ,QAAQ,CAACC,cAAc,CAAC,YAAY,CAAC;AACtD,IAAII,cAAc,GAAGL,QAAQ,CAACC,cAAc,CAAC,gBAAgB,CAAC;AAC9D,IAAIK,UAAU,GAAGN,QAAQ,CAACC,cAAc,CAAC,KAAK,CAAC;AAE/C,IAAIM,eAAe,GAAG,IAAI;AAE1B,SAASC,GAAGA,CAACC,GAAG,EAAE;EACdH,UAAU,CAACI,SAAS,IAAK,GAAED,GAAI,IAAG;AACpC;AAGA,SAASE,IAAIA,CAACC,SAAS,EAAE;EACvB,OAAO,IAAIC,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,SAAS,CAAC,CAAC;AACjE;AAEA,SAASI,cAAcA,CAACC,MAAM,EAAEC,UAAU,EAAE;EAC1C,IAAIC,QAAQ,GAAG,IAAIC,aAAa,CAACH,MAAM,CAAC;EACxC,IAAII,IAAI,GAAG,EAAE;EAEbF,QAAQ,CAACG,eAAe,GAAIC,KAAK,IAAKF,IAAI,CAACG,IAAI,CAACD,KAAK,CAACF,IAAI,CAAC;EAC3DF,QAAQ,CAACM,KAAK,EAAE;EAChBjB,GAAG,CAAE,GAAEW,QAAQ,CAACO,KAAM,QAAOR,UAAU,GAAG,IAAK,WAAU,CAAC;EAE1D,IAAIS,OAAO,GAAG,IAAId,OAAO,CAAC,CAACC,OAAO,EAAEc,MAAM,KAAK;IAC7CT,QAAQ,CAACU,MAAM,GAAGf,OAAO;IACzBK,QAAQ,CAACW,OAAO,GAAIP,KAAK,IAAKK,MAAM,CAACL,KAAK,CAACQ,IAAI,CAAC;EAClD,CAAC,CAAC;EAEF,IAAIC,QAAQ,GAAGrB,IAAI,CAACO,UAAU,CAAC,CAACe,IAAI,CAAC,MAAM;IACzC,IAAId,QAAQ,CAACO,KAAK,KAAK,WAAW,EAAE;MAClCP,QAAQ,CAACe,IAAI,EAAE;IACjB;EACF,CAAC,CAAC;EAEF,OAAOrB,OAAO,CAACsB,GAAG,CAAC,CAACR,OAAO,EAAEK,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAC,MAAMZ,IAAI,CAAC;AAC1D;AAGAlB,WAAW,CAACiC,gBAAgB,CAC1B,OAAO,EACP,MAAM;EACJC,SAAS,CAACC,YAAY,CACnBC,YAAY,CAAC;IACZC,KAAK,EAAE,IAAI;IACXC,KAAK,EAAE;EACT,CAAC,CAAC,CACDR,IAAI,CAAEhB,MAAM,IAAK;IAChBlB,OAAO,CAAC2C,SAAS,GAAGzB,MAAM;IAC1BZ,cAAc,CAACsC,IAAI,GAAG1B,MAAM;IAC5BlB,OAAO,CAAC6C,aAAa,GACnB7C,OAAO,CAAC6C,aAAa,IAAI7C,OAAO,CAAC8C,gBAAgB;IACnD,OAAO,IAAIhC,OAAO,CAAEC,OAAO,IAAMf,OAAO,CAAC+C,SAAS,GAAGhC,OAAQ,CAAC;EAChE,CAAC,CAAC,CACDmB,IAAI,CAAC,MAAMjB,cAAc,CAACjB,OAAO,CAAC6C,aAAa,EAAE,EAAErC,eAAe,CAAC,CAAC,CACpE0B,IAAI,CAAEc,cAAc,IAAK;IACxB,IAAIC,YAAY,GAAG,IAAIC,IAAI,CAACF,cAAc,EAAE;MAAEG,IAAI,EAAE;IAAa,CAAC,CAAC;IACnEhD,SAAS,CAACiD,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACL,YAAY,CAAC;IACjD3C,cAAc,CAACsC,IAAI,GAAGzC,SAAS,CAACiD,GAAG;IACnC9C,cAAc,CAACiD,QAAQ,GAAG,oBAAoB;IAE9C9C,GAAG,CACA,yBAAwBwC,YAAY,CAACO,IAAK,aAAYP,YAAY,CAACE,IAAK,SAAQ,CAClF;EACH,CAAC,CAAC,CACDM,KAAK,CAAEC,KAAK,IAAK;IAChB,IAAIA,KAAK,CAAC1B,IAAI,KAAK,eAAe,EAAE;MAClCvB,GAAG,CAAC,+CAA+C,CAAC;IACtD,CAAC,MAAM;MACLA,GAAG,CAACiD,KAAK,CAAC;IACZ;EACF,CAAC,CAAC;AACN,CAAC,EACD,KAAK,CACN;AACDrD,UAAU,CAACgC,gBAAgB,CACzB,OAAO,EACP,MAAM;EACJF,IAAI,CAACnC,OAAO,CAAC2C,SAAS,CAAC;AACzB,CAAC,EACD,KAAK,CACN;AAED,SAASR,IAAIA,CAACjB,MAAM,EAAE;EACpBA,MAAM,CAACyC,SAAS,EAAE,CAACC,OAAO,CAAEC,KAAK,IAAKA,KAAK,CAAC1B,IAAI,EAAE,CAAC;AACrD;;AAKF"},"metadata":{},"sourceType":"module","externalDependencies":[]}