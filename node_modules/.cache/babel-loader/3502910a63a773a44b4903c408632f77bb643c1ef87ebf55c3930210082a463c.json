{"ast":null,"code":"//import '../SkinTemptColor.html'\nimport './index.css';\nimport React, { useRef, useEffect } from 'react';\n\n// export function SkinTemptColor(props){\n\n//     const stopButton= document.getElementById(\"stopButton\");\n//     let preview = document.getElementById(\"preview\");\n//     let recordingTimeMS = 3000;\n//     let recording = document.getElementById(\"recording\");\n\n//     function wait(delayInMS) {\n//         return new Promise((resolve) => setTimeout(resolve, delayInMS));\n//       }\n\n//     function startRecording(stream, lengthInMS) {\n\n//         let recorder = new MediaRecorder(stream);\n//         let data = [];\n\n//         recorder.ondataavailable = (event) => data.push(event.data);\n//         recorder.start();\n//         //console.log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n\n//         let stopped = new Promise((resolve, reject) => {\n//           recorder.onstop = resolve;\n//           recorder.onerror = (event) => reject(event.name);\n//         });\n\n//         let recorded = wait(lengthInMS).then(() => {\n//           if (recorder.state === \"recording\") {\n//             recorder.stop();\n//           }\n\n//         });\n\n//         return Promise.all([stopped, recorded]).then(() => data);\n//       }\n\n//     function stop(stream) {\n//         stream.getTracks().forEach((track) => track.stop());\n//     }\n\n//     function handleClick(event){\n\n//         if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n//             navigator.mediaDevices.getUserMedia({\n//                 video: true\n//             })\n\n//             .then((stream) => {\n//                 preview.srcObject = stream;\n//                 //preview.requestPictureInPicture();\n\n//                 preview.captureStream =\n//                 preview.captureStream || preview.mozCaptureStream;\n//                 return new Promise((resolve) => (preview.onplaying = resolve));\n//             })\n//             .then(() => startRecording(preview.captureStream(), recordingTimeMS))\n//             .then((recordedChunks) => {\n//                 let recordedBlob = new Blob(recordedChunks, { type: \"video/webm\" });\n//                 recording.src = URL.createObjectURL(recordedBlob);\n\n//             console.log(\n//                 `Successfully recorded ${recordedBlob.size} bytes of ${recordedBlob.type} media.`\n//              );\n//             })\n//             .catch((error) => {\n//                 if (error.name === \"NotFoundError\") {\n//                     console.log(\"Camera or microphone not found. Can't record.\");\n//                 } else {\n//                     console.log('error');\n//             }\n//             });\n\n//         }\n\n//     }\n\n//     function handleStop(event){\n//         //let stopButton = document.getElementById(\"stopButton\");\n//         //preview.srcObject\n//         // if (preview !== null) { \n\n//         //     stop(preview.srcObject);\n\n//         // } \n//         // else{\n//             if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n\n//             navigator.mediaDevices.getUserMedia({\n//                 video: true\n//             }).then((stream) => {\n//                 preview.srcObject = stream;\n//                 preview.captureStream =\n//                 preview.captureStream || preview.mozCaptureStream;\n//                 return new Promise((resolve) => (preview.onpause = resolve));\n//             }).then(() => stop(preview.captureStream()))\n//             .catch((error) => {\n//                 if (error.name === \"NotFoundError\") {\n//                     console.log(\"Camera or microphone not found. Can't record.\");\n//                 } else {\n//                     console.log('error');\n//             }\n//             });\n\n//         // }\n//         }\n//     }\n\n//     function stopRecord (stream){\n//         let recorder = new MediaRecorder(stream);\n//         recorder.stop();\n//     }\n\n//     return (\n//         <div className=\"main-body\">\n\n//                 <p>this function will help you to know your skin Tempterature</p>\n//                 <p>camera required</p>\n//                 <div className=\"start\">\n//                     <button onClick={handleClick}> start testing</button>\n//                     <video id=\"preview\" width=\"160\" height=\"120\" autopplay=\"true\"></video>\n//                 </div>\n\n//                 <div>\n//                 {/* <video \n//                 ref={videoRef}\n//                 autoPlay\n//                 /> */}\n//                     {/* <h2>Recording</h2> */}\n//                     <video id=\"recording\" width=\"160\" height=\"120\" controls></video>\n//                 </div>\n//                 <div className=\"stop\">\n//                     <button onClick={handleStop} id=\"stopButton\" className=\"button\">Stop Recording</button>\n//                  </div>\n//         </div>\n\n//     );\n// }\n\n//export function SkinTemptColor(){\nlet preview = document.getElementById(\"preview\");\nlet recording = document.getElementById(\"recording\");\nlet startButton = document.getElementById(\"startButton\");\nlet stopButton = document.getElementById(\"stopButton\");\nlet downloadButton = document.getElementById(\"downloadButton\");\nlet logElement = document.getElementById(\"log\");\nlet recordingTimeMS = 5000;\nfunction log(msg) {\n  logElement.innerHTML += `${msg}\\n`;\n}\nfunction wait(delayInMS) {\n  return new Promise(resolve => setTimeout(resolve, delayInMS));\n}\nfunction startRecording(stream, lengthInMS) {\n  let recorder = new MediaRecorder(stream);\n  let data = [];\n  recorder.ondataavailable = event => data.push(event.data);\n  recorder.start();\n  log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n  let stopped = new Promise((resolve, reject) => {\n    recorder.onstop = resolve;\n    recorder.onerror = event => reject(event.name);\n  });\n  let recorded = wait(lengthInMS).then(() => {\n    if (recorder.state === \"recording\") {\n      recorder.stop();\n    }\n  });\n  return Promise.all([stopped, recorded]).then(() => data);\n}\nstartButton.addEventListener(\"click\", () => {\n  navigator.mediaDevices.getUserMedia({\n    video: true,\n    audio: true\n  }).then(stream => {\n    preview.srcObject = stream;\n    downloadButton.href = stream;\n    preview.captureStream = preview.captureStream || preview.mozCaptureStream;\n    return new Promise(resolve => preview.onplaying = resolve);\n  }).then(() => startRecording(preview.captureStream(), recordingTimeMS)).then(recordedChunks => {\n    let recordedBlob = new Blob(recordedChunks, {\n      type: \"video/webm\"\n    });\n    recording.src = URL.createObjectURL(recordedBlob);\n    downloadButton.href = recording.src;\n    downloadButton.download = \"RecordedVideo.webm\";\n    log(`Successfully recorded ${recordedBlob.size} bytes of ${recordedBlob.type} media.`);\n  }).catch(error => {\n    if (error.name === \"NotFoundError\") {\n      log(\"Camera or microphone not found. Can't record.\");\n    } else {\n      log(error);\n    }\n  });\n}, false);\nstopButton.addEventListener(\"click\", () => {\n  stop(preview.srcObject);\n}, false);\nfunction stop(stream) {\n  stream.getTracks().forEach(track => track.stop());\n}\n\n//}","map":{"version":3,"names":["React","useRef","useEffect","preview","document","getElementById","recording","startButton","stopButton","downloadButton","logElement","recordingTimeMS","log","msg","innerHTML","wait","delayInMS","Promise","resolve","setTimeout","startRecording","stream","lengthInMS","recorder","MediaRecorder","data","ondataavailable","event","push","start","state","stopped","reject","onstop","onerror","name","recorded","then","stop","all","addEventListener","navigator","mediaDevices","getUserMedia","video","audio","srcObject","href","captureStream","mozCaptureStream","onplaying","recordedChunks","recordedBlob","Blob","type","src","URL","createObjectURL","download","size","catch","error","getTracks","forEach","track"],"sources":["/Users/wangjiamin/Documents/GitHub/makeup-starters/src/SkinTemptColor.js"],"sourcesContent":["//import '../SkinTemptColor.html'\nimport './index.css';\nimport React, { useRef, useEffect} from 'react';\n\n \n\n// export function SkinTemptColor(props){\n\n//     const stopButton= document.getElementById(\"stopButton\");\n//     let preview = document.getElementById(\"preview\");\n//     let recordingTimeMS = 3000;\n//     let recording = document.getElementById(\"recording\");\n\n//     function wait(delayInMS) {\n//         return new Promise((resolve) => setTimeout(resolve, delayInMS));\n//       }\n\n//     function startRecording(stream, lengthInMS) {\n      \n       \n//         let recorder = new MediaRecorder(stream);\n//         let data = [];\n\n//         recorder.ondataavailable = (event) => data.push(event.data);\n//         recorder.start();\n//         //console.log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n        \n//         let stopped = new Promise((resolve, reject) => {\n//           recorder.onstop = resolve;\n//           recorder.onerror = (event) => reject(event.name);\n//         });\n      \n//         let recorded = wait(lengthInMS).then(() => {\n//           if (recorder.state === \"recording\") {\n//             recorder.stop();\n//           }\n\n         \n        \n\n//         });\n      \n//         return Promise.all([stopped, recorded]).then(() => data);\n//       }\n\n    \n//     function stop(stream) {\n//         stream.getTracks().forEach((track) => track.stop());\n//     }\n\n\n//     function handleClick(event){\n        \n//         if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n//             navigator.mediaDevices.getUserMedia({\n//                 video: true\n//             })\n            \n//             .then((stream) => {\n//                 preview.srcObject = stream;\n//                 //preview.requestPictureInPicture();\n\n//                 preview.captureStream =\n//                 preview.captureStream || preview.mozCaptureStream;\n//                 return new Promise((resolve) => (preview.onplaying = resolve));\n//             })\n//             .then(() => startRecording(preview.captureStream(), recordingTimeMS))\n//             .then((recordedChunks) => {\n//                 let recordedBlob = new Blob(recordedChunks, { type: \"video/webm\" });\n//                 recording.src = URL.createObjectURL(recordedBlob);\n\n//             console.log(\n//                 `Successfully recorded ${recordedBlob.size} bytes of ${recordedBlob.type} media.`\n//              );\n//             })\n//             .catch((error) => {\n//                 if (error.name === \"NotFoundError\") {\n//                     console.log(\"Camera or microphone not found. Can't record.\");\n//                 } else {\n//                     console.log('error');\n//             }\n//             });\n           \n           \n           \n//         }\n        \n//     }\n\n    \n//     function handleStop(event){\n//         //let stopButton = document.getElementById(\"stopButton\");\n//         //preview.srcObject\n//         // if (preview !== null) { \n            \n//         //     stop(preview.srcObject);\n\n//         // } \n//         // else{\n//             if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n                \n//             navigator.mediaDevices.getUserMedia({\n//                 video: true\n//             }).then((stream) => {\n//                 preview.srcObject = stream;\n//                 preview.captureStream =\n//                 preview.captureStream || preview.mozCaptureStream;\n//                 return new Promise((resolve) => (preview.onpause = resolve));\n//             }).then(() => stop(preview.captureStream()))\n//             .catch((error) => {\n//                 if (error.name === \"NotFoundError\") {\n//                     console.log(\"Camera or microphone not found. Can't record.\");\n//                 } else {\n//                     console.log('error');\n//             }\n//             });\n           \n            \n//         // }\n//         }\n//     }\n\n//     function stopRecord (stream){\n//         let recorder = new MediaRecorder(stream);\n//         recorder.stop();\n//     }\n\n//     return (\n//         <div className=\"main-body\">\n                \n//                 <p>this function will help you to know your skin Tempterature</p>\n//                 <p>camera required</p>\n//                 <div className=\"start\">\n//                     <button onClick={handleClick}> start testing</button>\n//                     <video id=\"preview\" width=\"160\" height=\"120\" autopplay=\"true\"></video>\n//                 </div>\n                    \n//                 <div>\n//                 {/* <video \n//                 ref={videoRef}\n//                 autoPlay\n//                 /> */}\n//                     {/* <h2>Recording</h2> */}\n//                     <video id=\"recording\" width=\"160\" height=\"120\" controls></video>\n//                 </div>\n//                 <div className=\"stop\">\n//                     <button onClick={handleStop} id=\"stopButton\" className=\"button\">Stop Recording</button>\n//                  </div>\n//         </div>\n        \n//     );\n// }\n\n//export function SkinTemptColor(){\n    let preview = document.getElementById(\"preview\");\nlet recording = document.getElementById(\"recording\");\nlet startButton = document.getElementById(\"startButton\");\nlet stopButton = document.getElementById(\"stopButton\");\nlet downloadButton = document.getElementById(\"downloadButton\");\nlet logElement = document.getElementById(\"log\");\n\nlet recordingTimeMS = 5000;\n\nfunction log(msg) {\n    logElement.innerHTML += `${msg}\\n`;\n  }\n  \n\n  function wait(delayInMS) {\n    return new Promise((resolve) => setTimeout(resolve, delayInMS));\n  }\n\n  function startRecording(stream, lengthInMS) {\n    let recorder = new MediaRecorder(stream);\n    let data = [];\n  \n    recorder.ondataavailable = (event) => data.push(event.data);\n    recorder.start();\n    log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n  \n    let stopped = new Promise((resolve, reject) => {\n      recorder.onstop = resolve;\n      recorder.onerror = (event) => reject(event.name);\n    });\n  \n    let recorded = wait(lengthInMS).then(() => {\n      if (recorder.state === \"recording\") {\n        recorder.stop();\n      }\n    });\n  \n    return Promise.all([stopped, recorded]).then(() => data);\n  }\n\n\n  startButton.addEventListener(\n    \"click\",\n    () => {\n      navigator.mediaDevices\n        .getUserMedia({\n          video: true,\n          audio: true,\n        })\n        .then((stream) => {\n          preview.srcObject = stream;\n          downloadButton.href = stream;\n          preview.captureStream =\n            preview.captureStream || preview.mozCaptureStream;\n          return new Promise((resolve) => (preview.onplaying = resolve));\n        })\n        .then(() => startRecording(preview.captureStream(), recordingTimeMS))\n        .then((recordedChunks) => {\n          let recordedBlob = new Blob(recordedChunks, { type: \"video/webm\" });\n          recording.src = URL.createObjectURL(recordedBlob);\n          downloadButton.href = recording.src;\n          downloadButton.download = \"RecordedVideo.webm\";\n  \n          log(\n            `Successfully recorded ${recordedBlob.size} bytes of ${recordedBlob.type} media.`\n          );\n        })\n        .catch((error) => {\n          if (error.name === \"NotFoundError\") {\n            log(\"Camera or microphone not found. Can't record.\");\n          } else {\n            log(error);\n          }\n        });\n    },\n    false\n  );\n  stopButton.addEventListener(\n    \"click\",\n    () => {\n      stop(preview.srcObject);\n    },\n    false\n  );\n  \n  function stop(stream) {\n    stream.getTracks().forEach((track) => track.stop());\n  }\n\n\n  \n  \n//}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}