{"ast":null,"code":"//import '../SkinTemptColor.html'\nimport './index.css';\nimport React, { useRef, useEffect } from 'react';\n\n// export function SkinTemptColor(props){\n\n//     const stopButton= document.getElementById(\"stopButton\");\n//     let preview = document.getElementById(\"preview\");\n//     let recordingTimeMS = 3000;\n//     let recording = document.getElementById(\"recording\");\n\n//     function wait(delayInMS) {\n//         return new Promise((resolve) => setTimeout(resolve, delayInMS));\n//       }\n\n//     function startRecording(stream, lengthInMS) {\n\n//         let recorder = new MediaRecorder(stream);\n//         let data = [];\n\n//         recorder.ondataavailable = (event) => data.push(event.data);\n//         recorder.start();\n//         //console.log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n\n//         let stopped = new Promise((resolve, reject) => {\n//           recorder.onstop = resolve;\n//           recorder.onerror = (event) => reject(event.name);\n//         });\n\n//         let recorded = wait(lengthInMS).then(() => {\n//           if (recorder.state === \"recording\") {\n//             recorder.stop();\n//           }\n\n//         });\n\n//         return Promise.all([stopped, recorded]).then(() => data);\n//       }\n\n//     function stop(stream) {\n//         stream.getTracks().forEach((track) => track.stop());\n//     }\n\n//     function handleClick(event){\n\n//         if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n//             navigator.mediaDevices.getUserMedia({\n//                 video: true\n//             })\n\n//             .then((stream) => {\n//                 preview.srcObject = stream;\n//                 //preview.requestPictureInPicture();\n\n//                 preview.captureStream =\n//                 preview.captureStream || preview.mozCaptureStream;\n//                 return new Promise((resolve) => (preview.onplaying = resolve));\n//             })\n//             .then(() => startRecording(preview.captureStream(), recordingTimeMS))\n//             .then((recordedChunks) => {\n//                 let recordedBlob = new Blob(recordedChunks, { type: \"video/webm\" });\n//                 recording.src = URL.createObjectURL(recordedBlob);\n\n//             console.log(\n//                 `Successfully recorded ${recordedBlob.size} bytes of ${recordedBlob.type} media.`\n//              );\n//             })\n//             .catch((error) => {\n//                 if (error.name === \"NotFoundError\") {\n//                     console.log(\"Camera or microphone not found. Can't record.\");\n//                 } else {\n//                     console.log('error');\n//             }\n//             });\n\n//         }\n\n//     }\n\n//     function handleStop(event){\n//         //let stopButton = document.getElementById(\"stopButton\");\n//         //preview.srcObject\n//         // if (preview !== null) { \n\n//         //     stop(preview.srcObject);\n\n//         // } \n//         // else{\n//             if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n\n//             navigator.mediaDevices.getUserMedia({\n//                 video: true\n//             }).then((stream) => {\n//                 preview.srcObject = stream;\n//                 preview.captureStream =\n//                 preview.captureStream || preview.mozCaptureStream;\n//                 return new Promise((resolve) => (preview.onpause = resolve));\n//             }).then(() => stop(preview.captureStream()))\n//             .catch((error) => {\n//                 if (error.name === \"NotFoundError\") {\n//                     console.log(\"Camera or microphone not found. Can't record.\");\n//                 } else {\n//                     console.log('error');\n//             }\n//             });\n\n//         // }\n//         }\n//     }\n\n//     function stopRecord (stream){\n//         let recorder = new MediaRecorder(stream);\n//         recorder.stop();\n//     }\n\n//     return (\n//         <div className=\"main-body\">\n\n//                 <p>this function will help you to know your skin Tempterature</p>\n//                 <p>camera required</p>\n//                 <div className=\"start\">\n//                     <button onClick={handleClick}> start testing</button>\n//                     <video id=\"preview\" width=\"160\" height=\"120\" autopplay=\"true\"></video>\n//                 </div>\n\n//                 <div>\n//                 {/* <video \n//                 ref={videoRef}\n//                 autoPlay\n//                 /> */}\n//                     {/* <h2>Recording</h2> */}\n//                     <video id=\"recording\" width=\"160\" height=\"120\" controls></video>\n//                 </div>\n//                 <div className=\"stop\">\n//                     <button onClick={handleStop} id=\"stopButton\" className=\"button\">Stop Recording</button>\n//                  </div>\n//         </div>\n\n//     );\n// }\n\nexport function SkinTemptColor() {\n  let preview = document.getElementById(\"preview\");\n  let recording = document.getElementById(\"recording\");\n  let startButton = document.getElementById(\"startButton\");\n  let stopButton = document.getElementById(\"stopButton\");\n  let downloadButton = document.getElementById(\"downloadButton\");\n  let logElement = document.getElementById(\"log\");\n  let recordingTimeMS = 5000;\n  function log(msg) {\n    logElement.innerHTML += `${msg}\\n`;\n  }\n  function wait(delayInMS) {\n    return new Promise(resolve => setTimeout(resolve, delayInMS));\n  }\n  function startRecording(stream, lengthInMS) {\n    let recorder = new MediaRecorder(stream);\n    let data = [];\n    recorder.ondataavailable = event => data.push(event.data);\n    recorder.start();\n    log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n    let stopped = new Promise((resolve, reject) => {\n      recorder.onstop = resolve;\n      recorder.onerror = event => reject(event.name);\n    });\n    let recorded = wait(lengthInMS).then(() => {\n      if (recorder.state === \"recording\") {\n        recorder.stop();\n      }\n    });\n    return Promise.all([stopped, recorded]).then(() => data);\n  }\n}\n_c = SkinTemptColor;\nvar _c;\n$RefreshReg$(_c, \"SkinTemptColor\");","map":{"version":3,"names":["React","useRef","useEffect","SkinTemptColor","preview","document","getElementById","recording","startButton","stopButton","downloadButton","logElement","recordingTimeMS","log","msg","innerHTML","wait","delayInMS","Promise","resolve","setTimeout","startRecording","stream","lengthInMS","recorder","MediaRecorder","data","ondataavailable","event","push","start","state","stopped","reject","onstop","onerror","name","recorded","then","stop","all","_c","$RefreshReg$"],"sources":["/Users/wangjiamin/Documents/GitHub/makeup-starters/src/SkinTemptColor.js"],"sourcesContent":["//import '../SkinTemptColor.html'\nimport './index.css';\nimport React, { useRef, useEffect} from 'react';\n\n \n\n// export function SkinTemptColor(props){\n\n//     const stopButton= document.getElementById(\"stopButton\");\n//     let preview = document.getElementById(\"preview\");\n//     let recordingTimeMS = 3000;\n//     let recording = document.getElementById(\"recording\");\n\n//     function wait(delayInMS) {\n//         return new Promise((resolve) => setTimeout(resolve, delayInMS));\n//       }\n\n//     function startRecording(stream, lengthInMS) {\n      \n       \n//         let recorder = new MediaRecorder(stream);\n//         let data = [];\n\n//         recorder.ondataavailable = (event) => data.push(event.data);\n//         recorder.start();\n//         //console.log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n        \n//         let stopped = new Promise((resolve, reject) => {\n//           recorder.onstop = resolve;\n//           recorder.onerror = (event) => reject(event.name);\n//         });\n      \n//         let recorded = wait(lengthInMS).then(() => {\n//           if (recorder.state === \"recording\") {\n//             recorder.stop();\n//           }\n\n         \n        \n\n//         });\n      \n//         return Promise.all([stopped, recorded]).then(() => data);\n//       }\n\n    \n//     function stop(stream) {\n//         stream.getTracks().forEach((track) => track.stop());\n//     }\n\n\n//     function handleClick(event){\n        \n//         if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n//             navigator.mediaDevices.getUserMedia({\n//                 video: true\n//             })\n            \n//             .then((stream) => {\n//                 preview.srcObject = stream;\n//                 //preview.requestPictureInPicture();\n\n//                 preview.captureStream =\n//                 preview.captureStream || preview.mozCaptureStream;\n//                 return new Promise((resolve) => (preview.onplaying = resolve));\n//             })\n//             .then(() => startRecording(preview.captureStream(), recordingTimeMS))\n//             .then((recordedChunks) => {\n//                 let recordedBlob = new Blob(recordedChunks, { type: \"video/webm\" });\n//                 recording.src = URL.createObjectURL(recordedBlob);\n\n//             console.log(\n//                 `Successfully recorded ${recordedBlob.size} bytes of ${recordedBlob.type} media.`\n//              );\n//             })\n//             .catch((error) => {\n//                 if (error.name === \"NotFoundError\") {\n//                     console.log(\"Camera or microphone not found. Can't record.\");\n//                 } else {\n//                     console.log('error');\n//             }\n//             });\n           \n           \n           \n//         }\n        \n//     }\n\n    \n//     function handleStop(event){\n//         //let stopButton = document.getElementById(\"stopButton\");\n//         //preview.srcObject\n//         // if (preview !== null) { \n            \n//         //     stop(preview.srcObject);\n\n//         // } \n//         // else{\n//             if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n                \n//             navigator.mediaDevices.getUserMedia({\n//                 video: true\n//             }).then((stream) => {\n//                 preview.srcObject = stream;\n//                 preview.captureStream =\n//                 preview.captureStream || preview.mozCaptureStream;\n//                 return new Promise((resolve) => (preview.onpause = resolve));\n//             }).then(() => stop(preview.captureStream()))\n//             .catch((error) => {\n//                 if (error.name === \"NotFoundError\") {\n//                     console.log(\"Camera or microphone not found. Can't record.\");\n//                 } else {\n//                     console.log('error');\n//             }\n//             });\n           \n            \n//         // }\n//         }\n//     }\n\n//     function stopRecord (stream){\n//         let recorder = new MediaRecorder(stream);\n//         recorder.stop();\n//     }\n\n//     return (\n//         <div className=\"main-body\">\n                \n//                 <p>this function will help you to know your skin Tempterature</p>\n//                 <p>camera required</p>\n//                 <div className=\"start\">\n//                     <button onClick={handleClick}> start testing</button>\n//                     <video id=\"preview\" width=\"160\" height=\"120\" autopplay=\"true\"></video>\n//                 </div>\n                    \n//                 <div>\n//                 {/* <video \n//                 ref={videoRef}\n//                 autoPlay\n//                 /> */}\n//                     {/* <h2>Recording</h2> */}\n//                     <video id=\"recording\" width=\"160\" height=\"120\" controls></video>\n//                 </div>\n//                 <div className=\"stop\">\n//                     <button onClick={handleStop} id=\"stopButton\" className=\"button\">Stop Recording</button>\n//                  </div>\n//         </div>\n        \n//     );\n// }\n\nexport function SkinTemptColor(){\n    let preview = document.getElementById(\"preview\");\nlet recording = document.getElementById(\"recording\");\nlet startButton = document.getElementById(\"startButton\");\nlet stopButton = document.getElementById(\"stopButton\");\nlet downloadButton = document.getElementById(\"downloadButton\");\nlet logElement = document.getElementById(\"log\");\n\nlet recordingTimeMS = 5000;\n\nfunction log(msg) {\n    logElement.innerHTML += `${msg}\\n`;\n  }\n  \n\n  function wait(delayInMS) {\n    return new Promise((resolve) => setTimeout(resolve, delayInMS));\n  }\n\n  function startRecording(stream, lengthInMS) {\n    let recorder = new MediaRecorder(stream);\n    let data = [];\n  \n    recorder.ondataavailable = (event) => data.push(event.data);\n    recorder.start();\n    log(`${recorder.state} for ${lengthInMS / 1000} seconds…`);\n  \n    let stopped = new Promise((resolve, reject) => {\n      recorder.onstop = resolve;\n      recorder.onerror = (event) => reject(event.name);\n    });\n  \n    let recorded = wait(lengthInMS).then(() => {\n      if (recorder.state === \"recording\") {\n        recorder.stop();\n      }\n    });\n  \n    return Promise.all([stopped, recorded]).then(() => data);\n  }\n  \n  \n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}